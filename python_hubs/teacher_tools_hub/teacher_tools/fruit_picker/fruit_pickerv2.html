<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Citrus Picker ‚Äî Dual Tray Zenith (Dev Batch x5)</title>
<style>
  :root{
    --bg:#f3f4f6;
    --card:#ffffff;
    --ink:#111827;
    --muted:#6b7280;
    --border:#d1d5db;
    --shadow: 0 10px 30px rgba(0,0,0,.08);
    --good:#16a34a;
    --bad:#dc2626;
    --warn:#f59e0b;
    --night:#0b1020;
    --nightInk:#dbeafe;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    background:var(--bg);
    color:var(--ink);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    user-select:none;
    touch-action: manipulation;
  }
  header{
    position:sticky; top:0; z-index:10;
    background:linear-gradient(#fff, rgba(255,255,255,.92));
    border-bottom:1px solid var(--border);
    padding:10px 12px;
  }
  .wrap{max-width:1080px;margin:0 auto;padding:12px;}
  .row{display:grid;gap:12px;}
  @media(min-width:920px){
    .row{grid-template-columns: 1.3fr .7fr;}
  }
  .card{
    background:var(--card);
    border:1px solid var(--border);
    border-radius:16px;
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .hd{
    padding:10px 12px;
    border-bottom:1px solid var(--border);
    display:flex;align-items:center;justify-content:space-between;gap:10px;
  }
  .title{font-weight:950;letter-spacing:.2px}
  .sub{color:var(--muted);font-size:12px;line-height:1.25}
  .pill{
    font-size:12px;
    padding:6px 10px;
    border:1px solid var(--border);
    border-radius:999px;
    background:#fff;
    color:var(--ink);
    white-space:nowrap;
  }
  .pill b{font-weight:950}
  .body{padding:12px}

  .btns{display:flex;flex-wrap:wrap;gap:8px}
  button{
    appearance:none;
    border:1px solid var(--border);
    background:#fff;
    color:var(--ink);
    border-radius:12px;
    padding:10px 12px;
    font-weight:900;
    cursor:pointer;
  }
  button.primary{
    background:#111827;
    color:#fff;
    border-color:#111827;
  }
  button:active{transform:translateY(1px)}
  select{
    border:1px solid var(--border);
    border-radius:12px;
    padding:10px 12px;
    background:#fff;
    font-weight:900;
  }

  .hint{font-size:12px;color:var(--muted);line-height:1.35;margin-top:10px}

  /* Game */
  .game{
    position:relative;
    height:580px;
    border:1px dashed var(--border);
    border-radius:16px;
    background:
      radial-gradient(circle at 20% 20%, rgba(0,0,0,.04), transparent 45%),
      radial-gradient(circle at 80% 30%, rgba(0,0,0,.03), transparent 50%),
      linear-gradient(#fff, #fafafa);
    overflow:hidden;
    touch-action:none;
  }

  /* Abort X (triple tap) */
  .abort{
    position:absolute;
    top:10px; right:10px;
    width:44px;height:44px;
    border-radius:14px;
    border:2px solid rgba(0,0,0,.25);
    background:#fff;
    display:grid;place-items:center;
    font-weight:950;
    color:#111827;
    cursor:pointer;
    z-index:6;
    box-shadow:0 8px 18px rgba(0,0,0,.10);
  }
  .abort small{
    position:absolute;
    bottom:-18px; right:0;
    font-size:11px;
    color:var(--muted);
    white-space:nowrap;
  }
  .abort.hot{
    border-color:var(--bad);
    box-shadow:0 0 0 3px rgba(220,38,38,.18), 0 10px 22px rgba(0,0,0,.12);
  }

  /* HUD */
  .hud{
    position:absolute;
    left:10px; top:10px;
    z-index:5;
    display:flex;
    flex-direction:column;
    gap:6px;
    pointer-events:none;
  }
  .hud .line{
    display:inline-flex;
    align-items:center;
    gap:8px;
    background:rgba(255,255,255,.90);
    border:1px solid rgba(0,0,0,.10);
    border-radius:999px;
    padding:6px 10px;
    font-size:12px;
    color:var(--muted);
    box-shadow:0 10px 18px rgba(0,0,0,.06);
  }
  .hud .line b{color:var(--ink)}
  .zenBadge{
    display:inline-flex;
    align-items:center;
    gap:8px;
    font-weight:950;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid rgba(22,163,74,.35);
    background:rgba(22,163,74,.10);
    color:var(--good);
  }

  /* Fruit */
  .fruit{
    position:absolute;
    width:66px;height:66px;
    display:grid;place-items:center;
    font-size:40px;
    filter: drop-shadow(0 8px 10px rgba(0,0,0,.18));
    border-radius:16px;
    background:rgba(255,255,255,.96);
    border:1px solid rgba(0,0,0,.10);
    transform:translate(-50%,-50%);
    cursor:grab;
    will-change:left, top;
  }
  .fruit:active{cursor:grabbing}

  .fruit.pepper{
    border-color: rgba(245,158,11,.55);
  }
  .fruit.pepper .tag{
    position:absolute;
    bottom:-10px; left:50%;
    transform:translateX(-50%);
    font-size:10px;
    font-weight:950;
    color:rgba(0,0,0,.55);
    background:rgba(255,255,255,.92);
    border:1px solid rgba(0,0,0,.12);
    border-radius:999px;
    padding:2px 6px;
  }
  .fruit.pepper.dead{
    opacity:.55;
    filter: grayscale(1) drop-shadow(0 8px 10px rgba(0,0,0,.12));
  }

  /* Bottom zones */
  .zones{
    position:absolute;
    left:50%;
    bottom:14px;
    transform:translateX(-50%);
    width:min(1000px, 96%);
    display:grid;
    grid-template-columns: 1fr 1.2fr;
    gap:10px;
    z-index:3;
    pointer-events:none;
  }

  /* Match Tray */
  .match{
    pointer-events:auto;
    height:156px;
    border-radius:20px;
    border:3px solid #111827;
    background: linear-gradient(135deg, rgba(0,0,0,.06), rgba(0,0,0,.02));
    padding:10px 12px;
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .match .top{
    display:flex;align-items:center;justify-content:space-between;gap:10px;
  }
  .match .top b{font-size:13px}
  .match .top span{font-size:12px;color:var(--muted)}
  .slots{
    display:grid;
    grid-template-columns: repeat(4, 1fr);
    gap:8px;
    flex:1;
  }
  .mslot{
    border-radius:16px;
    border:2px dashed rgba(0,0,0,.35);
    background:rgba(255,255,255,.80);
    display:grid;
    place-items:center;
    text-align:center;
    overflow:hidden;
    position:relative;
    min-height:86px;
  }
  .mslot .need{
    font-size:24px;
    line-height:1;
  }
  .mslot .needLbl{
    font-size:11px;
    color:var(--muted);
    margin-top:4px;
    font-weight:950;
    letter-spacing:.5px;
  }
  .mslot .fill{
    position:absolute;
    inset:0;
    display:grid;
    place-items:center;
    font-size:32px;
    background:rgba(255,255,255,.92);
    border-radius:14px;
    opacity:0;
    transform:scale(.98);
    transition:opacity .12s ease;
  }
  .mslot.filled .fill{opacity:1}
  .mslot.hot{
    border-color:var(--good);
    box-shadow:0 0 0 3px rgba(22,163,74,.18);
  }

  /* Drop Tray */
  .drop{
    pointer-events:auto;
    height:156px;
    border-radius:20px;
    border:3px solid #111827;
    background: linear-gradient(135deg, rgba(0,0,0,.06), rgba(0,0,0,.02));
    padding:10px 12px;
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .drop .top{
    display:flex;align-items:center;justify-content:space-between;gap:10px;
  }
  .drop .top b{font-size:13px}
  .drop .top span{font-size:12px;color:var(--muted)}
  .dropZone{
    flex:1;
    border-radius:18px;
    border:3px dashed rgba(0,0,0,.35);
    background:rgba(255,255,255,.80);
    display:grid;place-items:center;
    font-weight:950;
    letter-spacing:1px;
    color:rgba(0,0,0,.50);
    text-transform:uppercase;
  }
  .drop.hot{
    border-color:var(--good);
    box-shadow:0 0 0 4px rgba(22,163,74,.18);
  }

  /* 10-slot visual tray */
  .tray{
    display:grid;
    grid-template-columns: repeat(10, 1fr);
    gap:6px;
    padding:10px 12px;
    border-top:1px solid var(--border);
    background:#fff;
  }
  .slot{
    height:34px;
    border:1px solid var(--border);
    border-radius:10px;
    display:grid;place-items:center;
    background:#fafafa;
    font-size:18px;
  }
  .slot.filled{background:#fff;border-color:#cbd5e1}

  .status{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    padding:10px 12px;
    border-top:1px solid var(--border);
    background:#fff;
    font-size:13px;
    color:var(--muted);
  }
  .status b{color:var(--ink)}

  .toast{
    margin-top:10px;
    padding:10px 12px;
    border-radius:14px;
    border:1px solid var(--border);
    background:#fff;
    font-size:13px;
    color:var(--muted);
    line-height:1.35;
  }
  .toast.good{border-color:rgba(22,163,74,.35)}
  .toast.bad{border-color:rgba(220,38,38,.35)}
  .toast.warn{border-color:rgba(245,158,11,.35)}

  .miniGrid{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:10px;
    margin-top:10px;
  }
  .mini{
    border:1px solid var(--border);
    border-radius:14px;
    background:#fff;
    padding:10px 12px;
    color:var(--muted);
    font-size:12px;
    line-height:1.35;
  }
  .mini b{color:var(--ink);font-weight:950}
  .bigScore{
    font-size:28px;
    font-weight:950;
    letter-spacing:.4px;
    color:var(--ink);
  }

  textarea{
    width:100%;
    min-height:240px;
    resize:vertical;
    border:1px solid var(--border);
    border-radius:14px;
    padding:10px 12px;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    font-size:12px;
    line-height:1.35;
    background:var(--night);
    color:var(--nightInk);
  }
  .smallRow{
    display:flex; gap:8px; flex-wrap:wrap; align-items:center;
  }
</style>
</head>
<body>

<header>
  <div class="wrap" style="padding:0 12px;">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;">
      <div>
        <div class="title">Citrus Picker <span class="sub">‚Äî Dual Tray Zenith (Dev Batch x5)</span></div>
        <div class="sub">Forced 5 sessions. Ends: Zenith or Abort or Time. Peppers live 5s; double-tap to remove (+points). Non-zenith: leftover fruit becomes dead fruit.</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
        <span class="pill">Session: <b id="sessNum">1</b>/5</span>
        <span class="pill">Zenith: <b id="zenState">Locked</b></span>
        <span class="pill">Sound: <b id="soundState">Locked</b></span>
      </div>
    </div>
  </div>
</header>

<div class="wrap">
  <div class="row">
    <!-- LEFT -->
    <div class="card">
      <div class="hd">
        <div>
          <div class="title">Playfield</div>
          <div class="sub">Drag fruit into Match slots (exact) + Drop tray (10). Mistakes reduce accuracy. Double-tap peppers to destroy.</div>
        </div>
        <div class="pill">Score: <b id="scoreOut">0</b>/100</div>
      </div>

      <div class="body">
        <div id="game" class="game" aria-label="Game Area">
          <div class="hud">
            <div class="line">Time: <b id="timeLeft">--</b>s ‚Ä¢ Difficulty: <b id="diffHud">1</b></div>
            <div class="line">Accuracy: <b id="accPct">100</b>% ‚Ä¢ Mistakes: <b id="mistakes">0</b> ‚Ä¢ Dead: <b id="deadCount">0</b></div>
            <div class="line">Match: <b id="matchProg">0</b>/4 ‚Ä¢ Drop: <b id="dropProg">0</b>/10 ‚Ä¢ Pepper+: <b id="pepBonus">0</b></div>
            <div class="line" id="zenLine" style="display:none;"><span class="zenBadge">‚óá ZENITH ACHIEVED</span></div>
          </div>

          <div id="abortBtn" class="abort" title="Abort (triple tap)">‚úï<small><span id="abortTaps">0</span>/3 taps</small></div>

          <div class="zones">
            <div id="matchTray" class="match" aria-label="Match Tray">
              <div class="top">
                <b>Match Tray (Exact 4)</b>
                <span>Fill each slot once</span>
              </div>
              <div id="matchSlots" class="slots"></div>
            </div>

            <div id="dropTray" class="drop" aria-label="Drop Tray">
              <div class="top">
                <b>Drop Tray (Goal 10)</b>
                <span>Any fruit counts (overflow ‚Üí dead)</span>
              </div>
              <div id="dropZone" class="dropZone">DROP</div>
            </div>
          </div>
        </div>

        <div class="toast" id="toast">
          Press <b>Start</b>. Hint: if Drop stays 0/10, you‚Äôre not playing the full game loop.
        </div>

        <div class="miniGrid">
          <div class="mini">
            <div><b>Attempts</b>: <span id="attempts">0</span></div>
            <div><b>Correct</b>: <span id="correct">0</span></div>
            <div><b>Wrong</b>: <span id="wrong">0</span></div>
            <div><b>Peppers</b>: spawned <span id="pepSpawn">0</span> ‚Ä¢ destroyed <span id="pepKill">0</span> ‚Ä¢ expired <span id="pepExpire">0</span></div>
          </div>
          <div class="mini">
            <div class="bigScore"><span id="scoreBig">0</span><span style="font-size:14px;color:var(--muted);font-weight:950;">/100</span></div>
            <div style="margin-top:6px;" id="zenBadgeWrap"></div>
            <div style="margin-top:6px;color:var(--muted);font-size:12px;">
              Leftover on screen (non-zenith ‚Üí dead): <b id="leftovers">0</b>
            </div>
          </div>
        </div>
      </div>

      <div class="tray" id="tray10" aria-label="10-slot Visual Tray"></div>

      <div class="status">
        <div>Difficulty: <b id="diffLabel">1</b> ‚Ä¢ spawn_ms: <b id="spawnLabel">2600</b> ‚Ä¢ cap: <b id="capLabel">8</b> ‚Ä¢ limit: <b id="limitLabel">180</b>s</div>
        <div>Fruits: üçä üçã üçç üçí üçà + üå∂Ô∏è</div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="hd">
        <div>
          <div class="title">Dev Controls</div>
          <div class="sub">Forced batch: 5 sessions ‚Üí export unlocks (copy/paste).</div>
        </div>
        <div class="pill">User: <b>me</b></div>
      </div>
      <div class="body">
        <div class="btns">
          <button class="primary" id="startBtn">Start</button>
          <button id="pauseBtn">Pause</button>
          <button id="resetBatchBtn">Reset Batch</button>
        </div>

        <div class="smallRow" style="margin-top:10px;">
          <label class="pill">Difficulty
            <select id="diffSel" aria-label="Difficulty select">
              <option value="1" selected>1 (spawn 2600 ‚Ä¢ cap 8 ‚Ä¢ 180s)</option>
              <option value="2">2 (spawn 2000 ‚Ä¢ cap 10 ‚Ä¢ 150s)</option>
              <option value="3">3 (spawn 1500 ‚Ä¢ cap 12 ‚Ä¢ 135s)</option>
              <option value="4">4 (spawn 1200 ‚Ä¢ cap 14 ‚Ä¢ 120s)</option>
            </select>
          </label>
        </div>

        <div class="hint">
          <b>Zenith condition:</b> Score ‚â• <b>85</b> AND Match <b>4/4</b> AND Drop <b>10/10</b>.<br>
          <b>Abort:</b> triple-tap X (records ended_reason=abort).<br>
          <b>Timeout:</b> ends_reason=time (still saved).<br>
          <b>Peppers:</b> double-tap to destroy (+1 point; capped). After 5s ‚Üí dead pepper (no bonus).
        </div>

        <div style="margin-top:12px;">
          <div class="sub" style="margin-bottom:6px;">Export (unlocks after 5 sessions)</div>
          <div class="smallRow" style="margin-bottom:8px;">
            <button id="copyBtn">Copy Export</button>
            <span class="pill">Status: <b id="exportStatus">Locked</b></span>
          </div>
          <textarea id="exportBox" readonly>Complete 5 sessions to unlock export‚Ä¶</textarea>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // =========================
  // CONFIG (difficulty acknowledges your screenshot format)
  // =========================
  const USER_ID = "me";
  const BATCH_SIZE = 5;

  const FRUITS = [
    {key:'orange', emoji:'üçä'},
    {key:'lemon', emoji:'üçã'},
    {key:'pineapple', emoji:'üçç'},
    {key:'cherry', emoji:'üçí'},
    {key:'lime', emoji:'üçà'}
  ];
  const MATCH_KEYS = ['orange','lemon','cherry','lime'];

  const DIFF_CFG = {
    1: {spawn_ms:2600, cap:8,  limit_s:180, pepper_prob:0.06},
    2: {spawn_ms:2000, cap:10, limit_s:150, pepper_prob:0.08},
    3: {spawn_ms:1500, cap:12, limit_s:135, pepper_prob:0.10},
    4: {spawn_ms:1200, cap:14, limit_s:120, pepper_prob:0.12},
  };

  const PEPPER_LIVE_MS = 5000;
  const PEPPER_BONUS_CAP = 5; // max +points per session
  const STORAGE_KEY = "cp_dualtray_devbatch_v2";

  // Score weights
  const W_ACC  = 70;
  const W_DROP = 20;
  const W_MATCH= 10;
  const DEAD_PEN_MAX = 15;

  // =========================
  // ELEMENTS
  // =========================
  const game = document.getElementById('game');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resetBatchBtn = document.getElementById('resetBatchBtn');
  const diffSel = document.getElementById('diffSel');

  const sessNumEl = document.getElementById('sessNum');
  const zenStateEl = document.getElementById('zenState');
  const soundStateEl = document.getElementById('soundState');

  const scoreOutEl = document.getElementById('scoreOut');
  const scoreBigEl = document.getElementById('scoreBig');
  const accPctEl = document.getElementById('accPct');
  const mistakesEl = document.getElementById('mistakes');
  const deadCountEl = document.getElementById('deadCount');
  const matchProgEl = document.getElementById('matchProg');
  const dropProgEl = document.getElementById('dropProg');
  const pepBonusEl = document.getElementById('pepBonus');
  const timeLeftEl = document.getElementById('timeLeft');
  const diffHudEl = document.getElementById('diffHud');

  const attemptsEl = document.getElementById('attempts');
  const correctEl = document.getElementById('correct');
  const wrongEl = document.getElementById('wrong');
  const leftoversEl = document.getElementById('leftovers');

  const pepSpawnEl = document.getElementById('pepSpawn');
  const pepKillEl  = document.getElementById('pepKill');
  const pepExpireEl= document.getElementById('pepExpire');

  const matchSlotsEl = document.getElementById('matchSlots');
  const dropTrayEl = document.getElementById('dropTray');
  const tray10El = document.getElementById('tray10');

  const diffLabelEl = document.getElementById('diffLabel');
  const spawnLabelEl = document.getElementById('spawnLabel');
  const capLabelEl = document.getElementById('capLabel');
  const limitLabelEl = document.getElementById('limitLabel');

  const toast = document.getElementById('toast');
  const zenLine = document.getElementById('zenLine');
  const zenBadgeWrap = document.getElementById('zenBadgeWrap');

  const abortBtn = document.getElementById('abortBtn');
  const abortTapsEl = document.getElementById('abortTaps');

  const exportBox = document.getElementById('exportBox');
  const exportStatusEl = document.getElementById('exportStatus');
  const copyBtn = document.getElementById('copyBtn');

  // =========================
  // SOUND (WebAudio)
  // =========================
  let audioCtx = null;
  let soundUnlocked = false;
  function unlockSound(){
    if(soundUnlocked) return;
    try{
      audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      if(audioCtx.state === 'suspended') audioCtx.resume();
      soundUnlocked = true;
      soundStateEl.textContent = 'On';
    }catch(e){
      soundStateEl.textContent = 'Off';
    }
  }
  function popSound(ok=true){
    if(!soundUnlocked || !audioCtx) return;
    const t = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    const base = ok ? (260 + Math.random()*180) : (140 + Math.random()*80);
    o.type = 'sine';
    o.frequency.setValueAtTime(base, t);
    o.frequency.exponentialRampToValueAtTime(ok ? base*2.15 : base*0.85, t+0.05);
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(ok ? 0.18 : 0.12, t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t+0.10);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(t); o.stop(t+0.11);
  }

  // =========================
  // UTIL
  // =========================
  function setToast(msg, kind=''){
    toast.className = 'toast' + (kind ? (' ' + kind) : '');
    toast.innerHTML = msg;
  }
  function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
  function nowISO(){
    const d = new Date();
    const pad = (x) => String(x).padStart(2,'0');
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }
  function rand(min,max){ return Math.random()*(max-min)+min; }

  function loadState(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return {batch:[]};
      const obj = JSON.parse(raw);
      if(!obj || typeof obj !== 'object') return {batch:[]};
      if(!Array.isArray(obj.batch)) obj.batch = [];
      return obj;
    }catch(e){
      return {batch:[]};
    }
  }
  function saveState(st){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(st));
  }

  // =========================
  // GAME STATE
  // =========================
  let running = false;
  let paused = false;
  let ended = false;

  let diff = Number(diffSel.value);
  let cfg = DIFF_CFG[diff];

  let spawnTimer = null;
  let clockTimer = null;
  let tStart = null;
  let tEnd = null;
  let timeLeft = cfg.limit_s;

  // counters
  let attempts = 0;
  let correct = 0;
  let wrong = 0;

  let dropCount = 0;
  let tray10 = [];
  let matchState = {};

  // dead fruit logic
  let deadFruit = 0;

  // peppers
  let peppersSpawned = 0;
  let peppersDestroyed = 0;
  let peppersExpired = 0;
  let pepperBonusPoints = 0;

  // abort triple tap
  let abortTaps = 0;
  let abortTapTimer = null;

  // session index within forced batch
  let sessionNum = 1;

  // =========================
  // RENDER
  // =========================
  function renderMatchSlots(){
    matchSlotsEl.innerHTML = '';
    for(const key of MATCH_KEYS){
      const fruit = FRUITS.find(f => f.key === key);
      const slot = document.createElement('div');
      slot.className = 'mslot';
      slot.dataset.need = key;
      slot.innerHTML = `
        <div>
          <div class="need">${fruit ? fruit.emoji : '‚ùì'}</div>
          <div class="needLbl">NEED</div>
        </div>
        <div class="fill">‚úÖ</div>
      `;
      if(matchState[key]){
        slot.classList.add('filled');
        slot.querySelector('.fill').textContent = fruit ? fruit.emoji : '‚úÖ';
      }
      matchSlotsEl.appendChild(slot);
    }
  }

  function renderTray10(){
    tray10El.innerHTML = '';
    for(let i=0;i<10;i++){
      const slot = document.createElement('div');
      slot.className = 'slot' + (tray10[i] ? ' filled' : '');
      slot.textContent = tray10[i] || '';
      tray10El.appendChild(slot);
    }
  }

  function matchFilledCount(){
    return MATCH_KEYS.reduce((acc,k)=> acc + (matchState[k] ? 1 : 0), 0);
  }

  function fruitsOnScreen(){
    return [...game.querySelectorAll('.fruit')];
  }

  function leftoversCount(){
    return fruitsOnScreen().length;
  }

  // =========================
  // SCORE
  // =========================
  function computeScore(zenithOverride=false){
    const acc = attempts <= 0 ? 1 : (correct / attempts);
    const accScore = clamp(acc, 0, 1) * W_ACC;
    const dropScore = clamp(dropCount / 10, 0, 1) * W_DROP;
    const matchScore = clamp(matchFilledCount() / 4, 0, 1) * W_MATCH;

    const left = leftoversCount();
    const pen = zenithOverride ? 0 : (clamp(deadFruit / 10, 0, 1) * DEAD_PEN_MAX);

    const raw = accScore + dropScore + matchScore + pepperBonusPoints - pen;
    const score = clamp(raw, 0, 100);

    return {
      score: Math.round(score),
      accPct: Math.round(acc * 100),
      left,
      pen: Math.round(pen),
      accScore: Math.round(accScore),
      dropScore: Math.round(dropScore),
      matchScore: Math.round(matchScore),
      pepperBonus: pepperBonusPoints
    };
  }

  function isZenith(){
    const s = computeScore(true);
    return (s.score >= 85) && (matchFilledCount() === 4) && (dropCount >= 10);
  }

  function updateHUD(){
    const zen = isZenith();
    const s = computeScore(zen);

    scoreOutEl.textContent = String(s.score);
    scoreBigEl.textContent = String(s.score);

    accPctEl.textContent = String(s.accPct);
    mistakesEl.textContent = String(wrong);
    deadCountEl.textContent = String(deadFruit);

    matchProgEl.textContent = String(matchFilledCount());
    dropProgEl.textContent = String(dropCount);
    pepBonusEl.textContent = String(pepperBonusPoints);

    attemptsEl.textContent = String(attempts);
    correctEl.textContent = String(correct);
    wrongEl.textContent = String(wrong);

    leftoversEl.textContent = String(s.left);

    pepSpawnEl.textContent = String(peppersSpawned);
    pepKillEl.textContent = String(peppersDestroyed);
    pepExpireEl.textContent = String(peppersExpired);

    timeLeftEl.textContent = String(Math.max(0, timeLeft));
    diffHudEl.textContent = String(diff);

    zenStateEl.textContent = zen ? "Unlocked" : "Locked";
    zenLine.style.display = zen ? "" : "none";
    zenBadgeWrap.innerHTML = zen ? `<span class="pill" style="border-color:rgba(22,163,74,.35);background:rgba(22,163,74,.10);color:var(--good)"><b>‚óá ZENITH</b> ${s.score}/100</span>` : "";
  }

  // =========================
  // ATTEMPTS
  // =========================
  function registerAttempt(ok){
    attempts += 1;
    if(ok) correct += 1;
    else { wrong += 1; }
  }

  // =========================
  // PEPPER
  // =========================
  function markPepperDead(el){
    if(el.dataset.pepperDead === "1") return;
    el.dataset.pepperDead = "1";
    el.classList.add('dead');
    el.querySelector('.tag').textContent = 'DEAD';
    peppersExpired += 1;
  }

  function destroyPepper(el, rewarded){
    // remove pepper from play
    el.remove();
    deadFruit += 1; // removing counts as "allocated away" but still tracked (you asked for dead fruit counters)
    if(rewarded){
      peppersDestroyed += 1;
      if(pepperBonusPoints < PEPPER_BONUS_CAP){
        pepperBonusPoints += 1;
      }
      setToast('üå∂Ô∏è Destroyed (bonus +1)', 'good');
      popSound(true);
    }else{
      setToast('üå∂Ô∏è Cleared (no bonus)', 'warn');
      popSound(false);
    }
  }

  // =========================
  // SPAWN
  // =========================
  function maybeSpawnPepper(){
    return Math.random() < cfg.pepper_prob;
  }

  function spawnFruitOrPepper(){
    if(!running || paused || ended) return;

    // cap control
    const count = fruitsOnScreen().length;
    if(count >= cfg.cap) return;

    const rect = game.getBoundingClientRect();

    const isPep = maybeSpawnPepper();
    let obj = null;

    const el = document.createElement('div');
    el.className = 'fruit';

    if(isPep){
      peppersSpawned += 1;
      el.classList.add('pepper');
      el.textContent = 'üå∂Ô∏è';
      el.dataset.kind = 'pepper';
      el.dataset.pepperBorn = String(Date.now());
      el.dataset.pepperDead = "0";
      const tag = document.createElement('div');
      tag.className = 'tag';
      tag.textContent = 'LIVE';
      el.appendChild(tag);

      // pepper auto-expire after 5 seconds (becomes dead fruit if not removed)
      setTimeout(() => {
        if(!el.isConnected) return;
        // if still on screen, become dead
        markPepperDead(el);
        updateHUD();
      }, PEPPER_LIVE_MS);

      // double tap to remove (no UI change)
      el.addEventListener('dblclick', (ev) => {
        ev.stopPropagation();
        unlockSound();
        const rewarded = (el.dataset.pepperDead !== "1"); // only reward if still live
        destroyPepper(el, rewarded);
        updateHUD();
      });

    }else{
      obj = FRUITS[Math.floor(Math.random()*FRUITS.length)];
      el.textContent = obj.emoji;
      el.dataset.kind = obj.key;

      // Tap counts as a mistake (forces drag)
      el.addEventListener('click', (ev) => {
        ev.stopPropagation();
        unlockSound();
        registerAttempt(false);
        setToast('Tap = mistake. Drag to trays.', 'warn');
        popSound(false);
        updateHUD();
      });
    }

    // spawn away from bottom zones
    const x = rand(30, rect.width - 30);
    const y = rand(55, rect.height - 230);
    el.style.left = x + 'px';
    el.style.top  = y + 'px';

    // drag/drop
    let dragging = false;
    let offsetX = 0, offsetY = 0;

    el.addEventListener('pointerdown', (ev) => {
      unlockSound();
      dragging = true;
      el.setPointerCapture(ev.pointerId);
      const r = el.getBoundingClientRect();
      offsetX = ev.clientX - r.left;
      offsetY = ev.clientY - r.top;
      el.style.transition = 'none';
    });

    el.addEventListener('pointermove', (ev) => {
      if(!dragging) return;
      const g = game.getBoundingClientRect();
      const nx = ev.clientX - g.left - offsetX + (el.offsetWidth/2);
      const ny = ev.clientY - g.top - offsetY + (el.offsetHeight/2);
      el.style.left = nx + 'px';
      el.style.top  = ny + 'px';

      // highlight trays for accuracy
      const er = el.getBoundingClientRect();

      const dr = dropTrayEl.getBoundingClientRect();
      const overDrop = !(er.right < dr.left || er.left > dr.right || er.bottom < dr.top || er.top > dr.bottom);
      dropTrayEl.classList.toggle('hot', overDrop);

      [...matchSlotsEl.querySelectorAll('.mslot')].forEach(s => {
        const sr = s.getBoundingClientRect();
        const over = !(er.right < sr.left || er.left > sr.right || er.bottom < sr.top || er.top > sr.bottom);
        s.classList.toggle('hot', over);
      });
    });

    el.addEventListener('pointerup', () => {
      if(!dragging) return;
      dragging = false;

      dropTrayEl.classList.remove('hot');
      [...matchSlotsEl.querySelectorAll('.mslot')].forEach(s => s.classList.remove('hot'));

      const er = el.getBoundingClientRect();

      // match slots first
      let placed = false;
      const slots = [...matchSlotsEl.querySelectorAll('.mslot')];
      for(const s of slots){
        const sr = s.getBoundingClientRect();
        const over = !(er.right < sr.left || er.left > sr.right || er.bottom < sr.top || er.top > sr.bottom);
        if(over){
          placed = true;
          const need = s.dataset.need;

          // peppers are NEVER correct for match
          if(el.dataset.kind === 'pepper'){
            registerAttempt(false);
            setToast('‚ùå Pepper does not belong in Match Tray (counts as mistake).', 'bad');
            popSound(false);
            updateHUD();
            return;
          }

          const ok = (el.dataset.kind === need) && !matchState[need];
          registerAttempt(ok);

          if(ok){
            matchState[need] = true;
            popSound(true);
            setToast('‚úÖ Correct match slot!', 'good');
            el.remove();
            renderMatchSlots();
          }else{
            popSound(false);
            setToast('‚ùå Wrong match (or already filled). Accuracy down.', 'bad');
          }
          updateHUD();
          checkEndOrContinue();
          return;
        }
      }

      // drop tray
      const dr = dropTrayEl.getBoundingClientRect();
      const overDrop = !(er.right < dr.left || er.left > dr.right || er.bottom < dr.top || er.top > dr.bottom);

      if(overDrop){
        // peppers: allowed, no penalty, but never help dropCount
        if(el.dataset.kind === 'pepper'){
          registerAttempt(false);
          deadFruit += 1;
          el.remove();
          popSound(false);
          setToast('üå∂Ô∏è Dropped pepper ‚Üí counts as dead fruit + mistake (no score penalty beyond accuracy/dead).', 'warn');
          updateHUD();
          checkEndOrContinue();
          return;
        }

        if(dropCount < 10){
          registerAttempt(true);
          dropCount += 1;
          tray10.push(el.textContent);
          tray10 = tray10.slice(0,10);
          renderTray10();
          popSound(true);
          setToast('‚úÖ Drop tray +1', 'good');
          el.remove();
        }else{
          // overflow: no direct score subtraction; counts as dead fruit + mistake
          registerAttempt(false);
          deadFruit += 1;
          popSound(false);
          setToast('Drop tray full ‚Üí fruit becomes dead (mistake).', 'bad');
          el.remove();
        }
        updateHUD();
        checkEndOrContinue();
        return;
      }

      // missed all
      registerAttempt(false);
      popSound(false);
      setToast('‚ùå Missed trays. Accuracy down.', 'bad');
      updateHUD();
      checkEndOrContinue();
    });

    game.appendChild(el);
    updateHUD();
  }

  // =========================
  // TIMER / END CONDITIONS
  // =========================
  function stopTimers(){
    if(spawnTimer) clearInterval(spawnTimer);
    if(clockTimer) clearInterval(clockTimer);
    spawnTimer = null;
    clockTimer = null;
  }

  function endSession(reason){
    if(ended) return;
    ended = true;
    tEnd = Date.now();
    stopTimers();

    const zen = (reason === 'zenith');
    // If not zenith: everything left becomes dead fruit (your rule)
    if(!zen){
      const left = leftoversCount();
      if(left > 0){
        deadFruit += left;
      }
    }

    // clear board (so next session starts clean)
    [...game.querySelectorAll('.fruit')].forEach(el => el.remove());

    const s = computeScore(zen);

    // save record into batch
    const st = loadState();
    if(!Array.isArray(st.batch)) st.batch = [];

    const record = {
      session: sessionNum,
      started_at: new Date(tStart).toISOString().slice(0,19),
      ended_at: new Date(tEnd).toISOString().slice(0,19),
      ended_reason: reason,
      difficulty: diff,
      spawn_ms: cfg.spawn_ms,
      cap: cfg.cap,
      limit_s: cfg.limit_s,
      pepper_prob: cfg.pepper_prob,
      score_100: s.score,
      zenith: zen,
      accuracy_pct: s.accPct,
      attempts,
      correct,
      wrong,
      match_filled: matchFilledCount(),
      drop_count: dropCount,
      leftovers: zen ? 0 : leftoversCount(),
      dead_fruit: deadFruit,
      pepper_spawned: peppersSpawned,
      pepper_destroyed: peppersDestroyed,
      pepper_expired: peppersExpired,
      pepper_bonus_points: pepperBonusPoints,
      duration_s: Math.round((tEnd - tStart)/1000)
    };

    st.batch.push(record);
    saveState(st);

    // advance session number
    if(sessionNum < BATCH_SIZE){
      sessionNum += 1;
      sessNumEl.textContent = String(sessionNum);
      setToast(`Session ended (${reason}). Press Start for session ${sessionNum}/5.`, reason === 'zenith' ? 'good' : (reason === 'time' ? 'warn' : 'warn'));
      startBtn.textContent = `Start (Session ${sessionNum}/5)`;
    }else{
      // batch complete: export
      setToast(`Batch complete (5/5). Export is unlocked.`, 'good');
      startBtn.textContent = 'Batch Complete';
      exportStatusEl.textContent = 'Unlocked';
      exportBox.value = buildExportBlock(st.batch.slice(-BATCH_SIZE));
    }

    updateHUD();
  }

  function checkEndOrContinue(){
    if(ended) return;
    if(isZenith()){
      endSession('zenith');
      return;
    }
    // continue until time/abort/zenith
  }

  function tickClock(){
    if(!running || paused || ended) return;
    timeLeft -= 1;
    updateHUD();
    if(timeLeft <= 0){
      endSession('time');
    }
  }

  // =========================
  // ABORT (triple tap X)
  // =========================
  function resetAbortTaps(){
    abortTaps = 0;
    abortTapsEl.textContent = "0";
    abortBtn.classList.remove('hot');
    if(abortTapTimer) clearTimeout(abortTapTimer);
    abortTapTimer = null;
  }

  abortBtn.addEventListener('click', () => {
    unlockSound();
    if(!running || ended) return;
    abortTaps += 1;
    abortTapsEl.textContent = String(abortTaps);
    abortBtn.classList.add('hot');
    popSound(false);

    if(abortTapTimer) clearTimeout(abortTapTimer);
    abortTapTimer = setTimeout(() => {
      resetAbortTaps();
    }, 1200);

    if(abortTaps >= 3){
      resetAbortTaps();
      endSession('abort');
    }
  });

  // =========================
  // START / PAUSE / RESET
  // =========================
  function applyDiffFromUI(){
    diff = Number(diffSel.value);
    cfg = DIFF_CFG[diff];

    diffLabelEl.textContent = String(diff);
    spawnLabelEl.textContent = String(cfg.spawn_ms);
    capLabelEl.textContent = String(cfg.cap);
    limitLabelEl.textContent = String(cfg.limit_s);
    diffHudEl.textContent = String(diff);
  }

  function resetSessionState(){
    attempts = 0; correct = 0; wrong = 0;
    dropCount = 0;
    tray10 = [];
    matchState = {};
    MATCH_KEYS.forEach(k => matchState[k] = false);

    deadFruit = 0;

    peppersSpawned = 0;
    peppersDestroyed = 0;
    peppersExpired = 0;
    pepperBonusPoints = 0;

    renderMatchSlots();
    renderTray10();
    zenLine.style.display = "none";
    zenBadgeWrap.innerHTML = "";
    ended = false;
    paused = false;
    resetAbortTaps();
  }

  function startSession(){
    unlockSound();
    const st = loadState();
    const batch = Array.isArray(st.batch) ? st.batch : [];

    // force dev batch: if batch already complete, do nothing until Reset Batch
    const last5 = batch.slice(-BATCH_SIZE);
    if(last5.length === BATCH_SIZE){
      exportStatusEl.textContent = 'Unlocked';
      exportBox.value = buildExportBlock(last5);
      setToast('Batch already complete. Use Reset Batch to run a new set of 5 sessions.', 'warn');
      return;
    }

    // sessionNum should follow batch length + 1
    sessionNum = last5.length + 1;
    sessNumEl.textContent = String(sessionNum);

    applyDiffFromUI();
    resetSessionState();

    // clear board
    [...game.querySelectorAll('.fruit')].forEach(el => el.remove());

    timeLeft = cfg.limit_s;
    running = true;
    ended = false;
    paused = false;

    tStart = Date.now();
    tEnd = null;

    setToast(`Session ${sessionNum}/5 started. Focus: Drop tray AND Match tray.`, 'good');

    stopTimers();
    spawnTimer = setInterval(spawnFruitOrPepper, cfg.spawn_ms);
    clockTimer = setInterval(tickClock, 1000);

    updateHUD();
  }

  function togglePause(){
    if(!running || ended) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    setToast(paused ? 'Paused.' : 'Resumed.', '');
  }

  function resetBatch(){
    stopTimers();
    running = false;
    paused = false;
    ended = false;

    // clear storage
    saveState({batch:[]});

    sessionNum = 1;
    sessNumEl.textContent = "1";
    exportStatusEl.textContent = 'Locked';
    exportBox.value = 'Complete 5 sessions to unlock export‚Ä¶';

    // clear board + reset session state
    [...game.querySelectorAll('.fruit')].forEach(el => el.remove());
    applyDiffFromUI();
    resetSessionState();
    timeLeft = cfg.limit_s;
    updateHUD();

    startBtn.textContent = 'Start';
    pauseBtn.textContent = 'Pause';
    setToast('Batch reset. Forced 5 sessions begins again.', '');
  }

  // =========================
  // EXPORT (copy/paste ready)
  // =========================
  function buildExportBlock(records){
    // aggregate totals + by difficulty
    const byD = {};
    const agg = {
      sessions: records.length,
      zenith: 0,
      abort: 0,
      time: 0,
      attempts: 0, correct: 0, wrong: 0,
      dead_fruit: 0,
      pepper_spawned: 0,
      pepper_destroyed: 0,
      pepper_expired: 0,
      pepper_bonus_points: 0,
      score_sum: 0
    };

    for(const r of records){
      agg.score_sum += r.score_100;
      agg.attempts += r.attempts;
      agg.correct += r.correct;
      agg.wrong += r.wrong;
      agg.dead_fruit += r.dead_fruit;
      agg.pepper_spawned += r.pepper_spawned;
      agg.pepper_destroyed += r.pepper_destroyed;
      agg.pepper_expired += r.pepper_expired;
      agg.pepper_bonus_points += r.pepper_bonus_points;

      if(r.zenith) agg.zenith += 1;
      if(r.ended_reason === 'abort') agg.abort += 1;
      if(r.ended_reason === 'time') agg.time += 1;

      if(!byD[r.difficulty]){
        byD[r.difficulty] = {sessions:0, attempts:0, correct:0, wrong:0, score_sum:0, zenith:0};
      }
      const d = byD[r.difficulty];
      d.sessions += 1;
      d.attempts += r.attempts;
      d.correct += r.correct;
      d.wrong += r.wrong;
      d.score_sum += r.score_100;
      d.zenith += r.zenith ? 1 : 0;
    }

    const acc = agg.attempts ? (agg.correct / agg.attempts * 100) : 0;
    const avgScore = records.length ? (agg.score_sum / records.length) : 0;

    const lines = [];
    lines.push("```txt");
    lines.push("CITRUS_DUALTRAY_EXPORT v2");
    lines.push(`user_id=${USER_ID}`);
    lines.push(`generated=${nowISO()}`);
    lines.push("");
    lines.push("AGGREGATE (last 5 sessions)");
    lines.push(`- sessions=${agg.sessions} zenith=${agg.zenith} abort=${agg.abort} time=${agg.time}`);
    lines.push(`- attempts=${agg.attempts} correct=${agg.correct} wrong=${agg.wrong} accuracy=${acc.toFixed(1)}%`);
    lines.push(`- avg_score_100=${avgScore.toFixed(1)}`);
    lines.push(`- dead_fruit_total=${agg.dead_fruit}`);
    lines.push(`- peppers: spawned=${agg.pepper_spawned} destroyed=${agg.pepper_destroyed} expired=${agg.pepper_expired} bonus_points=${agg.pepper_bonus_points}`);
    lines.push("");
    lines.push("BY_DIFFICULTY");
    Object.keys(byD).sort((a,b)=>Number(a)-Number(b)).forEach(k => {
      const d = byD[k];
      const dAcc = d.attempts ? (d.correct/d.attempts*100) : 0;
      const dAvg = d.sessions ? (d.score_sum/d.sessions) : 0;
      lines.push(`- d${k}: sessions=${d.sessions} zenith=${d.zenith} attempts=${d.attempts} accuracy=${dAcc.toFixed(1)}% avg_score=${dAvg.toFixed(1)}`);
    });
    lines.push("");
    lines.push("SESSIONS");
    records.forEach(r => {
      lines.push(`SESSION ${r.session}/5`);
      lines.push(`- started_at: ${r.started_at}`);
      lines.push(`- ended_at: ${r.ended_at}`);
      lines.push(`- ended_reason: ${r.ended_reason}`);
      lines.push(`- difficulty: ${r.difficulty} (spawn_ms=${r.spawn_ms}, cap=${r.cap}, limit_s=${r.limit_s}, pepper_prob=${r.pepper_prob})`);
      lines.push(`- score_100: ${r.score_100}`);
      lines.push(`- zenith: ${r.zenith}`);
      lines.push(`- accuracy_pct: ${r.accuracy_pct}`);
      lines.push(`- attempts: ${r.attempts} (correct=${r.correct} wrong=${r.wrong})`);
      lines.push(`- match_filled: ${r.match_filled}/4`);
      lines.push(`- drop_count: ${r.drop_count}/10`);
      lines.push(`- dead_fruit: ${r.dead_fruit}`);
      lines.push(`- peppers: spawned=${r.pepper_spawned} destroyed=${r.pepper_destroyed} expired=${r.pepper_expired} bonus_points=${r.pepper_bonus_points}`);
      lines.push(`- duration_s: ${r.duration_s}`);
      lines.push("");
    });
    lines.push("REQUEST");
    lines.push("Analyze accuracy + mistakes; recommend tuning: spawn_ms, cap, pepper_prob, and zenith threshold if needed.");
    lines.push("```");
    return lines.join("\n");
  }

  async function copyExport(){
    const text = exportBox.value || "";
    if(!text.trim()){
      setToast('Nothing to copy yet.', 'warn');
      return;
    }
    try{
      await navigator.clipboard.writeText(text);
      setToast('Export copied to clipboard.', 'good');
    }catch(e){
      // fallback: select textarea
      exportBox.focus();
      exportBox.select();
      setToast('Select + copy manually (clipboard blocked).', 'warn');
    }
  }

  // =========================
  // EVENTS
  // =========================
  startBtn.addEventListener('click', startSession);
  pauseBtn.addEventListener('click', togglePause);
  resetBatchBtn.addEventListener('click', resetBatch);
  diffSel.addEventListener('change', () => {
    applyDiffFromUI();
    updateHUD();
  });
  copyBtn.addEventListener('click', copyExport);
  document.addEventListener('pointerdown', unlockSound, {passive:true, once:true});

  // =========================
  // INIT
  // =========================
  applyDiffFromUI();
  resetSessionState();

  const st = loadState();
  const last5 = (st.batch || []).slice(-BATCH_SIZE);
  if(last5.length === BATCH_SIZE){
    exportStatusEl.textContent = 'Unlocked';
    exportBox.value = buildExportBlock(last5);
    startBtn.textContent = 'Batch Complete';
  }else{
    exportStatusEl.textContent = 'Locked';
    exportBox.value = `Complete 5 sessions to unlock export‚Ä¶`;
    startBtn.textContent = 'Start';
  }

  timeLeft = cfg.limit_s;
  updateHUD();
})();
</script>

</body>
</html>